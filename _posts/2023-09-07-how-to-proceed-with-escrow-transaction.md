---
layout: single
title: 분산 환경에서 Lock을 최소 점유하면서 로직에 집중할수 있는 방법?
date: 2023-09-07 12:00
categories: 
  - oracle
author: 
tags: 
   - oracle
   - escrow
summary: escrow 기법으로 트랜잭션 처리 하는 방법에 대해서 설명합니다. 
toc : true
---

분산 환경에서 혹은 트랜잭션 경합이 심한 업무 환경에서 사용할수 있는 논리적인 트랜잭션 기법을 소개합니다. 

## 업무를 고려한 트랜잭션 기법이 필요

분산환경에서 느슨한 트랜잭션 처리하거나 혹은 어떤 예약시스템에서 재고수량을 동시에 수정해야하는 경우 DBMS내의 일반 트랜잭션 처리방법으로 힘들수 있습니다.
트랜잭션의 시작과 끝은 변경된 데이터의 Lock점유를 의미하고 여러 트랜잭션이 동시에 같은 데이터를 변경하려고 하면 어느 한 업무는 대기할수 밖에 없습니다. 
그래서 좀더 트랜잭션을 빠르게 처리하게 SQL을 튜닝하거나 트랜잭션 단위를 쪼개서 실행합니다. 

여기에서 트랜잭션 처리하기 힘든 업무에 대해서 몇가지 정리해보았습니다. 
동시에 같은 컬럼에 같은 값을 변경하는 트랜잭션들이 존재하거나, 트랜잭션자체가 오래걸리는 업무가 있을수 있습니다. 

- 업무 #1) 티켓 예약하는 시스템이 있다고 가정하겠습니다. 티켓 예약시스템에서 가장 중요한것은 재고 관리 하는 방법 일 것 같습니다. 저는 애플리케이션 경험이 많지 않아서 애플리케이션에서 어떻게 처리했는지는 말씀드릴수 없지만, 최소한 데이터베이스 관점에서 여러개의 트랜잭션이 동시에 특정 로우의 특정 컬럼의 값을 변경하기 위해서 실행되는것으로 상상하겠습니다.
그럴 경우 아무리 빠르게 트랜잭션을 처리하더라고 Lock은 회피하기 어려워 보입니다. 
- 제가 상상하는 로직은 아래와 같습니다. 
  - 먼저 재고 수량을 확인한다 (재고 수량한 값이 변경되면 안되기 때문에, SELECT .. FOR UPDATE로 해당 상품의 재고수량에 LOCK을 점유할것입니다. )
  - 재고 수량에 주문한 수량을 반영한다 (재고 수량이 100개이면, 여기에 5개가 주문되면, UPDATE SET Qty = Qty-5 이렇게 반영할것으로 생각되네요)
  - 그런다음에 결제서비스와 연동해서 완료되면 그때 트랜잭션을 완료시키기 위해서 Commit을 할것 같습니다.

어떤까요? 여러개의 트랜잭션이 같은 상품에 주문을 하면 주문이 빠르게 처리가 될까요? 
재고 수량의 일관성 유지를 위하여 여러의 주문이 들어와도 실제 처리되는 주문은 맨처음 SELECT * FROM UPDATE를 먼저 수행한 주문이겠죠?

- 업무 #2) MSA 환경에서 트랜잭션을 처리하기 위해서 SAGA 패턴을 사용했습니다. 주문업무는 내부적으로 재고서비스, 배송서비스, 결제서비스와 연결이 되어 있습니다. 
- 제가 상상하는 로직은 아래와 같습니다. 
  - 먼저 재고 서비스에가서 재고 수량이 있는지 확인합니다. 
  - 재고 수량이 있으면 주문수량만큼 차감시켜 놓습니다.
  - 결제서비스에 결제 요청을 합니다. 
  - 결제가 완료되면 트랜잭션을 모두 완료처리하고 배송서비스에 배송 요청을 합니다. 
  - 이렇게 정상적으로 수행되면 되는데 갑자기 결제서비스에 문제가 발생되었습니다. 결제 요청을 하다가 Fail이 발생되었습니다. 
  - 주문 프로세스 중에 결제 서비스가 문제가 생겼으므로 재고 서비스에 주문 수량을 취소해달라고 보상 로직이 실행합니다.

분산된 환경에서는 서비스별로 분리가 되어 있기때문에 트랜잭션 처리가 어렵습니다. 혹여나 그중 하나의 서비스가 문제 생기면 트랜잭션을 Rollback을 해주는 보상로직이 필요합니다.(rollback하기 전까지 해당 데이터에 LOCK점유된 상태로 유지되고 있습니다.)
그런데 보상로직이 수행되다가 stuck이 되었습니다. 무응답입니다. 그럼 영영 새로운주문은 처리 되지 않을것입니다. 왜냐하면 재고서비스에서 아직 살아 있는 트랜잭션이 다른 트랜잭션에서 데이터변경을 막고 있을것이기 때문입니다.

간단하게 위 사례를 통해서 DBMS에서 일반적으로 사용하는 트랜잭션 처리방식으로는 업무특성을 고려했을때 처리하기 힘든것을 확인했습니다. 

## ESCROW 트랜잭션 처리 방법

DBMS에서 모두 처리하기 힘들었으면 애플리케이션레벨에서 로직으로 해결하셨을것 같습니다.
이러한 업무를 처리할때 DB내에서 로직으로 트랜잭션을 처리할수 있는 방법에 대해서 소개시켜드릴려고 합니다. 

ESCROW 개념을 이용하여 트랜잭션 처리 하는 로직으로 만들수 있습니다. 
> ESCROW는 거래를 완료하는 과정에 있는 다른 두 당사자를 대신하여 제3자가 자산이나 금전을 보유하는 금융 계약을 설명하는 법적 개념입니다.(위키피디아 발췌) 

ESCROW 개념을 이용하면 Lock을 회피하는 트랜잭션 처리할수 있는 로직을 설계할수 있습니다. 
여러 트랜잭션에서 동일한 데이터에 변경이 요청되면 내부적으로 트랜잭션 목록(제3의 테이블)을 관리하여 트랜잭션이 완료되기전까지 실제 데이터를 변경하지 않고 있습니다.
데이터가 변경되지 않았다는 의미는 Lock을 점유하지 않는다는것이므로 여러 트랜잭션이 동시에 실행되어도 다른 트랜잭션상태와 관계없이 처리가 가능하다는것을 의미합니다. 

트랜잭션 처리 방법을 전통적인 트랜잭션 처리와 ESCROW로 명명한 트랜잭션 처리 기법과 비교해보도록 하겠습니다. 

- 트랜재션 처리 방법의 비교
  - 전통적인 트랜잭션 처리 방법 
    - 설명 : 트랜잭션이 완료되기 전까지는 다른 트랜잭션에서는 해당 컬럼의 값을 변경하지 못하고 대기해야합니다.
    - 동작방식 : update구문이 실행되면 해당 row에 Lock을 점유합니다., row에 실제 변경된 값으로 변경하고 변경전의 row정보는 undo에 저장합니다.(추후 트랜잭션 rollback을 위해 사용됨). 이러한 방식이 DBMS에 의해서 동작하는 일반방식이며 row값을 변경했으므로 트랜잭션이 완료되기 전까지는 계속 Lock을 점유한 상태로 유지합니다. 다른 트랜잭션에서 동일한 row의 값을 변경하려고 하면 lock점유를 위하여 대기해야합니다.
    - 고려사항 : 트랜잭션이 길게 유지될 경우 문제가 될수 있습니다. 동일한 row에 업데이트하는 트랜잭션이 발생되면 해당 트랜잭션은 LOCK이 발생되므로 업무가 원활하게 처리 안될수 있습니다. 대부분의 일반적인 상황에서는 동일한 row을 변경하지 않도록 업무에서 제어합니다.
  - ESCROW 트랜잭션 처리 방법
    - 설명 : 같은 row의 특정 컬럼에 동시에 여러 사용자가 변경이 가능(lock free)
    - 동작방식 : update 구문이 실행되면 해당 row에 Lock을 점유하고 해당 row에 값을 변경하는것이 아니라 journal 테이블에 변경요청한 데이터를 추가합니다. 해당 row에 값을 변경한것이 아니므로 Lock을 점유하지 않습니다. 다른 트랜잭션에서는 동일한 row에 값을 변경하여도 동일하게 lock을 점유하지 않고 동작합니다. 트랜잭션이 commit되는 순간에 해당 row에 데이터가 반영합니다.
    - 고려사항 : 트랜잭션을 오래 유지하여도 Lock 경함이 발생되지 않습니다. 그러나 특정 row의 값이 변경될수 있는 범위를 지정할 필요가 있습니다(예로 티켓예약을 하는데 재고가 없으면 안되는 업무있기 때문입니다.). 컬럼의 제약조건을 파악할때 jornal 테이블에 있는 데이터와 현재 row의 데이터를 sum하여 계산하도록 로직이 추가해야합니다. 전통적인 트랜잭션 처리에 비해서 내부 처리하는 SQL 개수가 많아지므로(journal 테이블관리, 현재 값을 계산하는 로직 수행) 단일 트랜잭션 속도는 저하될수 있습니다.

ESCROW 트랜잭션 처리방식에서는 곧바로 데이터를 수정하는것이 아니라 트랜잭션 목록에서 수정될 값들을 관리하고, 잠재적으로 처리될것으로 가정하고 관리합니다.

ESCROW 트랜잭션 처리시 고려사항
  - 동시에 변경가능한 데이터 형식은 number여야합니다 ( journal테이블에 이력을 저장하고 현재 값을 계산하기 위하여 number여야 aggregate(sum)이 가능하기 때문입니다.)
  - update문 요청시에는 set qty = qty -1 이런식으로 구문이 작성되어야합니다. 

ESCROW 트랜잭션 처리 구현 방식
 - 사전작업 
   - 어떤 테이블에 어떤 컬럼을 Escrow로 처리할것인지 지정합니다. 추가적으로 해당 컬럼값의 범위를 지정합니다. (max값 혹은 min값을 지정)
   - 그럼 테이블에 trigger 생성합니다. 
     - 로직 #1) 해당 컬럼의 limit에 도달했는지 확인 합니다. ( Journal 테이블의 데이터와 실제 데이터를 sum하여 limit값에 도달했는지 확인하는 로직추가)
       - limit값에 도달했으면 update는 실패로 에러 발생시킴(exception)
     - 로직 #2) update수행되면 해당 컬럼의 값을 곧바로 변경하는것이 아니라 journal테이블에 변경의 상대값을을 저장되도록 설정( +10, -10 등으로 상대적인 값을 저장)
 - 트랜잭션 실행
   - update SQL문장이 실행되어 완료되면, 일단 해당 컬럼의 값을 일부분을 선점한것으로 간주됩니다.
   - 이후에 업무에 필요한 다른 로직을 수행하면됩니다. (여러개의 update구문이 동시에 수행되어도 동시에 처리 가능)
 - 트랜잭션 완료(Commit)
   - Journal 테이블에 변경정보를 원본데이터를 실제 값을 반영해주고 Journal 테이블에 변경정보를 삭제합니다.
  
## 오라클 23c에 추가된 Lock Free Reserveration 기능

어떤가요? 구현하기 어렵죠? 

이런 방식이 처리가능하도록 나오는 기능이 오라클 데이터베이스에 있습니다. 바로 Lock Free Reserveration 기능입니다. 23c New Feature로 추가되었습니다. 

분산환경에서, 동일 로우의 컬럼 값을 여러트랜잭션에서 동시에 변경하기 위하여 나온 기능입니다.
위에 "ESCROW 트랜잭션 처리 구현 방식" 처럼 복잡하게 구성하지 않고 컬럼에 RESERABLE 속성을 지정만 하면 자동으로 ESCROW 방법으로 트랜잭션이 처리됩니다. 
```sql
ALTER TABLE ticketsales MODIFY qty number RESERVABLE CONSTRAINT MINIMUM_CAPACITY CHECK (qty >= 10)
```
## 결론

트랜잭션중에 절대 발생하면 안되는것은 Dead Lock입니다. 트랜잭션을 처리할때 가장 중요하게 생각하는 Lock 점유시간입니다. 트랜잭션 단위가 너무 길어서 불필요한 Lock을 점유하고 있지는 않는지 업무 로직을 구현할때 항상 생각하시면 좋을것 같습니다. 
업무에 따라서 다양한 아이디어로 트랜잭션을 설계할텐데 DB레벨에서 ESCROW를 이용한 트랜잭션 기능을 오라클데이터베이스도 제공하고 있으니 관심 있으면 테스트후에 활용하셨으면 좋겠습니다. 